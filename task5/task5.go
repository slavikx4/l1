package main

import (
	"context"
	"fmt"
	"math/rand"
	"time"
)

// основной поток
func main() {

	// контекст вместе с таймаутом вернёт канал, когда закончится время
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// канал через который будут ходить данные
	ch := make(chan int)

	// функция, которая будет читать данные
	go func() {
		// как только канал закроется, итератор закроется
		for num := range ch {
			fmt.Printf("%d\t", num)
		}
	}()

	// функция, которая вводит данные
	go func() {
		// итератор for без условий, для бесконечности
		for {
			// выбор между действиями (закрыть канал или записать данные)
			select {
			// конекст вернул канал => время вышло
			case <-ctx.Done():
				// заркрываем канал, чтобы читающая горутина тоже закрылась
				close(ch)
				// выходим из функции, чтобы не начался новая итерация
				return
			// если время выполнения программы ещё осталось
			default:
				// Sleep вызвал для более лаконичного вывода в консоль
				time.Sleep(1 * time.Second)
				// запись рандоомного числа в канал
				ch <- rand.Int()
			}
		}
	}()

	// вызовится, когда закончится время
	<-ctx.Done()
}
